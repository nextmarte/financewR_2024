[
  {
    "objectID": "Finance_with_R_1_2022.html",
    "href": "Finance_with_R_1_2022.html",
    "title": "Caderno_ Finanças 1",
    "section": "",
    "text": "Inicialização e carregar pacotes."
  },
  {
    "objectID": "Finance_with_R_1_2022.html#bibliografia",
    "href": "Finance_with_R_1_2022.html#bibliografia",
    "title": "Caderno_ Finanças 1",
    "section": "Bibliografia:",
    "text": "Bibliografia:\nRegenstein Jr., Jonathan K.;Reproducible Finance with R, CRC press, 2019.\nPerlin, Marcelo S.; Processing and Anlyzing Financial Data with R, 2018. disponível em :https://www.msperlin.com/padfeR/\nPicerno, James; Quantitative investment Portfoilo Analytic in R,LLC, 2018."
  },
  {
    "objectID": "Finance_with_R_1_2022.html#finanças-com-r-aula-1---retornos-dos-ativos",
    "href": "Finance_with_R_1_2022.html#finanças-com-r-aula-1---retornos-dos-ativos",
    "title": "Caderno_ Finanças 1",
    "section": "Finanças com R Aula 1 - Retornos dos ativos",
    "text": "Finanças com R Aula 1 - Retornos dos ativos\n\nSumário\n\nImportar os preços dos ativos da internet em arquivos .csv ou .xls\nTransformar os preços diários em mensais.\nObter os retornos mensais.\nVisualizar os retornos mensais.\nCalcular o retorno do portifólio utilizando os retornos mensais e pesos.\nVisualizar o retorno do portifólio.\nSalvar os dados para utilização posterior.\n\n\n\nAtivos x Retorno\nO objetvo de investir é fazer lucros. As receitas ou perdas dependem dos valores investidos e das variações nos preços dos ativos escolhidos. Obter o maior ganho ante ao valor investido isto é o desejado.\nA medida para isto se dá através dos retornos, obtidos pelo cálculo da variação dos preços em certo horizonte de tempo, i.e diário, mensal ou mesmo anual.\nA fim de mantermos coerência com o livro texto (Regenstein Jr., 2019) iremos utilizar os mesmos ativos e períodos ali analisados. Nosso objetivo será obter o retorno de 5 ativos e montar e analisar o retono de uma carteira formada com eles.\n\nSPY (fundo com S&P500) com peso 25%\nEFA (um fundo que contém MSCI índices da Europa, Australia, asia e oriente) com peso 25%\nIJS (small-cap:fundos especiais de inovação que se especializam em empresas pequenas e inovadoras) com peso 20%\nEEM (Um fundo de mercados emergentes) com peso 20%\nAGG (um fundo de títulos de renda fixa) com peso 10% Uma breve explicação sobre carteiras ou portifólios: um portfólio é uma coleção de ativos cujos pesos somam 100%. (sua etimologia remete ao latim para “carregar folhas de papel”, que eu suponho que essa denominação se dê no mundo dos investimentos porque títulos costumavam ser folhas de papel). A razão teórica de que os investidores racionais preferem uma carteira a um único ativo é que uma carteira pode oferecer uma melhor relação risco / retorno devido à baixa ou negativa covariância entre os componentes da carteira.\n\nAo longo do texto estaremos trabalhando em quatro diferentes paradígmas da utilização de dados com R, mais utillizados pela indústria, a saber: xts; tidyverse, tidyquant e o novo tibbletime. Cada um deles tem facilidades específicas que estaremos explorando em nosso aprendizado.\nVamos carregar os pacotes.\n\nlibrary(tidyverse)\nlibrary(lubridate)\nlibrary(readxl)\nlibrary(highcharter)\nlibrary(tidyquant)\nlibrary(tibbletime)\nlibrary(quantmod)\nlibrary(PerformanceAnalytics)\nlibrary(scales)\nlibrary(timetk)\nlibrary(here)\n\nDe volta a nossa tarefa: transformar a coleção de preços diários dos ativos em um objeto que armazene os log retornos do portifólio.\n\nImportar os preços dos ativos da internet em arquivos .csv ou .xls\nNesta primeira seção iremos aprender a importar os dados: da internet ou de arquivos .csv ou .xls de forma resumida para não divergir de nossos objetivos.\nO vetor symbols conterá nossos “tickers”.\n\nsymbols &lt;- c(\"SPY\",\"EFA\", \"IJS\", \"EEM\",\"AGG\")\n\nEstes “tickers” são abreviações que denominam nossos ativos nos diversos ambientes, i.e. BOVESPA, CBOT etc..\n\nExercício 1\nEncontre no Yahoo os tickers de Petrobras (a mais liquida), Vale, Friboi, Bradesco,e o índice Bovespa e armazene-os num vetor denominado “ativos”.\n\n\nImportando dados com o pacote quantmod\nO pacote quantmod é bem poderoso e permite obter dados de diversas fontes: * Yahoo! Finance (OHLC data) * Federal Reserve Bank of St. Louis FRED® (11,000 economic series) * Google Finance (OHLC data) * Oanda, The Currency Site (FX and Metals) * MySQL databases (Your local data) * R binary formats (.RData and .rda) * Comma Separated Value files (.csv) e outros estão em desevolvimento (RODBC,economagic,Rbloomberg,…).\nExistem diversas ferramentas para tratar os diferentes estágios de negócios mobiliários, entretanto ainda não há uma ferramenta completa no R que trate de todo o fluxo desde a coleta, do manuseio do dado, e da análise dos resultados da operação.\nO objeto prices vai armazenar os preços dos ativos pesquisados.\n\nprices &lt;- \n  getSymbols(symbols, \n             src = 'yahoo', \n             from = \"2012-12-31\",\n             to = \"2017-12-31\",\n             auto.assign = TRUE, \n             warnings = FALSE,) %&gt;% \n  map(~Ad(get(.))) %&gt;% \n  reduce(merge) %&gt;%\n  `colnames&lt;-`(symbols)\n\nNa primeira instrução passamos nosso vetor de “tickers” para a função getSymbols ( ) do pacote quantmod, doravante utilizaremos a notação quantmod::getSymbols. Veja: getSymbols().\nO argumento src indica que estaremos importando estes dados o Yahoo.\nOs dois parametros seguintes estabelecem o período para o qual coletaremos os dados. Estaremos fixando a data inicial em dezembro de 2012 para que tenhamos os retornos de 5 anos. Se você desejasse os dados até hoje não necessitaria de fixar a data final, poderia pular o argumento to.\nPara isolar o preço ajustado utilizou-se purrr::map e Ad(get(.)) que nos fornecerá o preço ajustado de cada uma das séries de preços.\nNote que originalmente a função getSymbols( ) importou os preços OHLC (open, high, low, close). Assim, se quisermos o preço de fechamento utilizaríamos Cl(get(.)).\nA função reduce(merge) vai unir os vetores de preços em um único objeto xts. A função merge utiliza a referência do índice de data para alinhar os objetos.\nPor fim renomeamos as colunas com os “tickers” com a instrução colnames&lt;-(symbols)\nVerifique as quatro primeiras linhas de prices.\n\nhead(prices,4)\n\n                SPY      EFA      IJS      EEM      AGG\n2012-12-31 116.1451 41.22703 34.19090 34.83741 84.13486\n2013-01-02 119.1219 41.86508 35.12902 35.52080 84.03642\n2013-01-03 118.8528 41.45905 35.08254 35.26944 83.82430\n2013-01-04 119.3747 41.66931 35.35721 35.34013 83.91518\n\n\nObserve a sua classe\n\nclass(prices)\n\n[1] \"xts\" \"zoo\"\n\n\nA instrução head ( ) é utilizada pois a classe do objeto lido é xts zoo, Extensible Time Series, ou uma série de tempo extensível. E faz parte dos tipos de objetos adicionados ao R para tratar séries temporais.\nEste formato é uma classe especial do objeto zoo do pacote de mesmo nome e consiste num array quase sempre uma matriz que contem um índice que fornece indicação sobre seu ordenamento. O objeto xts tem três caracterísitcas que o diferem do zoo, o uso formal do indexamento pela base de tempo, propriedades internas do xts e atributos que podem ser atribuídos pelo usuário. Para mais informações veja: xts object\n\n\n\nExercício 2\nObtenha os preços dos ativos do exercício 1 para o último ano.\n\n\nImportando dados em .csv\nBaixe os dados prices.csv do seu diretório da aula e coloque-os no mesmo diretório de trabalho, que como já foi orientado deverá ser um de seu projeto. Se não pôs ali utilize no console file.choose() e ache o caminho até seu arquivo.\nUtilizaremos a função readr::read_csv\n\n# prices.fromcsv&lt;-read_csv(\"Reproducible Finance.csv\",\n#                  col_types = \n#                    cols(date =\n#                           col_date(format = \"%Y-%m-%d\"))) %&gt;% \n#   tk_xts(date_var = date)\n\nA função read::read_csv nos possibilit a importação. Entretanto, interpretará nossa coluna de datas como numérico, para ajustar especificaremos a coluna com o formato ISO ano-mês-dia, com a instrução: col_types = cols(date = col_date(format = “%Y-%m-%d”))\nPor fim a função timetk::tk_xts converte o data frame para um objeto xts. Isto porque desejamos manter a coerência com a versão anterior de prices obtida com getSymbols( ).\nQuando o arquivo for .xls utiliza-se a função readxl::read_excel( ).\n\nprices.fromxlsx&lt;-\n  read_excel(\"/Users/alevy/Downloads/Reproducible Finance.xlsx\",\n                 col_types = c(\"text\", \"numeric\",\n                               \"numeric\",\"numeric\",\n                               \"numeric\",\"numeric\")) %&gt;% \n  mutate( date = ymd(date)) %&gt;% \n  tk_xts(date_var = date)\n\nTambém aqui teremos que converter a coluna de datas para um formato adequado, utilizamos o dplyr::mutate com a função lubridate::ymd( ).\nAssim, apresentamos três formas de importação dos dados e ao fazê-lo adicionamos mais algumas ferramentas ao nosso conjunto.\n\n\nConvertendo preços diários em retornos mensais.\nPrimeiro utilizaremos os dados em xts.\nNossa primeira observação no objeto prices datava de 31, de dezembro de 2012 (última observação de pregão daquele ano). Converteremos com base na data final do mês, se desejassemos o primeiro faríamos indexAt = “firstof”.\n\nprices_monthly &lt;- to.monthly(prices, indexAt = \"lastof\", OHLC = FALSE)\nhead(prices_monthly,4)\n\n                SPY      EFA      IJS      EEM      AGG\n2012-12-31 116.1451 41.22703 34.19090 34.83741 84.13486\n2013-01-31 122.0906 42.76416 36.02067 34.73529 83.61222\n2013-02-28 123.6483 42.21310 36.60805 33.94192 84.10631\n2013-03-31 128.3434 42.76416 38.11188 33.59630 84.18919\n\n\nObserve que agora temos apenas uma observação por mês, no novo objeto que ainda se mantém na classe xts.\n\n\n\nObtendo retornos com objetos xts\n\nasset_returns_xts &lt;-\n PerformanceAnalytics::Return.calculate(prices_monthly, \n                   method = \"log\") %&gt;% \n  na.omit()\nhead(asset_returns_xts,4)\n\n                  SPY         EFA         IJS          EEM           AGG\n2013-01-31 0.04992323  0.03660622 0.052133497 -0.002935511 -0.0062313540\n2013-02-28 0.01267830 -0.01296967 0.016175101 -0.023105323  0.0058918791\n2013-03-31 0.03726793  0.01296967 0.040257985 -0.010234863  0.0009850025\n2013-04-30 0.01902986  0.04896768 0.001222678  0.012084534  0.0096388961\n\n\nNormalmente quando abordamos o termo retorno nos referimos ao retorno linear, calculado por: \\[ Retorno\\,linear = \\frac{Preço_{final}-Preço_{inicial}}{Preço_{inicial}}\\]\nNa academia utiliza-se mais os log retornos.\n\nExercício 3\nSuponha que uma ação caia 50% e depois sobe 50%, de quanto foi a variação total no período? dica(Componha o retorno destes dois períodos utilizando juros compostos.)\nPara calcular o log retorno utiliza-se: \\[ Log\\,Retorno = \\ln(\\frac{Preço_{final}}{Preço_{inicial}})\\]\n####Exercício 4 Suponha que uma ação caia 50% e depois sobe 50%, de quanto foi a variação total no período? dica (utilize os log retornos)\nComo converter um no outro?\n\\[ Retorno\\,linear = e^{Log\\,Retorno}-1\\] \\[ Log\\,Retorno = \\ln(1+Retorno\\,linear)\\]\nQuanto menores os valores dos retornos em módulo mais o retorno linear se aproxima do log-retorno. Então, tudo bem utilizar o log retorno para facilitar as contas. Contudo não esqueça de apresentar seus resultados com retornos lineares. As pessoas nnão estão acostumadas a pensar com log-retornos. Quando dizemos que um ativo subiu 20% associamos a alteração dos preços de 100 para 120 e não para 122,1 que corresponderia ao log-retorno."
  },
  {
    "objectID": "Finance_with_R_1_2022.html#convertendo-preços-diários-em-retornos-mensais-no-ambiente-tidyverse-parei",
    "href": "Finance_with_R_1_2022.html#convertendo-preços-diários-em-retornos-mensais-no-ambiente-tidyverse-parei",
    "title": "Caderno_ Finanças 1",
    "section": "Convertendo preços diários em retornos mensais no ambiente tidyverse PAREI",
    "text": "Convertendo preços diários em retornos mensais no ambiente tidyverse PAREI\n\nasset_returns_dplyr_byhand &lt;- \n  prices %&gt;% \n  to.monthly(indexAt = \"lastof\", OHLC = FALSE) %&gt;%\n  tk_tbl(preserve_index = TRUE, rename_index = \"date\") %&gt;%\n  tbl_time(index = \"date\") %&gt;%\n  pivot_longer(cols = -date, names_to = \"asset\", values_to = \"returns\") %&gt;%\n  group_by(asset) %&gt;%  \n  mutate(returns = (log(returns) - log(lag(returns)))) %&gt;%\n  pivot_wider(names_from = asset, values_from = returns) %&gt;% \n  select(date, SPY, EFA, IJS, EEM, AGG) %&gt;% \n  na.omit()\n\nO código acima resolve a questão. Tome seu tempo e rode 3 linhas por vez observando as transformações ocorridas.\nFinalmente vamos verificar o novo objeto, e descrever as diferenças.\n\nhead(asset_returns_dplyr_byhand)\n\n# A tibble: 6 × 6\n  date           SPY     EFA      IJS      EEM       AGG\n  &lt;date&gt;       &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n1 2013-01-31  0.0499  0.0366  0.0521  -0.00294 -0.00623 \n2 2013-02-28  0.0127 -0.0130  0.0162  -0.0231   0.00589 \n3 2013-03-31  0.0373  0.0130  0.0403  -0.0102   0.000985\n4 2013-04-30  0.0190  0.0490  0.00122  0.0121   0.00964 \n5 2013-05-31  0.0233 -0.0307  0.0420  -0.0495  -0.0202  \n6 2013-06-30 -0.0134 -0.0271 -0.00140 -0.0547  -0.0158  \n\n\nSe não tivéssemos omitidos os NAs haveria uma observação em 2012-12-31 com NA em todas as colunas.\n\nConvertendo preços diários em retornos mensais no tidyquant.\nVamos explorar este novo tipo de ambiente obtendo os log-retornos. Iniciaremos com a função timetk::tk_tbl(). Na porção de código abaixo utilizaremos a instrução:\ntk_tbl(preserve_index = TRUE, rename_index = “date”)\nque transforma prices de xts em um tibble, converte o índices de datas em uma coluna, e renomeia ele como date. Veja que não foi preciso removê-lo como fizemos anteriormente.\nNa sequência em ves de utilizar to.monthly e mutate e escrevendo noso cálculo utilizamos a instrução:\ntq_transmute(mutate_fun = periodReturn, period = “monthly”, type = “log”)\nque permite ir diretamente de preços diários a log-retornos.\n\nasset_returns_tq_builtin &lt;- \n  prices %&gt;%\n  tk_tbl(preserve_index = TRUE, rename_index = \"date\") %&gt;%\n  pivot_longer(cols = -date, names_to = \"asset\", values_to = \"prices\") %&gt;%\n  group_by(asset) %&gt;%\n  mutate(returns = log(prices) - log(lag(prices))) %&gt;%\n  pivot_wider(names_from = asset, values_from = returns) %&gt;%\n  select(date, SPY, EFA, IJS, EEM, AGG) %&gt;%\n  na.omit() %&gt;%\n  slice(-1)\n\nMais uma vez precisamos retirar a observação que aparece com NAs. Desta vez utilizamos a instrução slice(-1). Cuidado como sinal! Se utilizar equivocadamnte slice(1) terminará somente com a primeira linha.\nO método tidyquant produz exatamente o mesmo resultado que com o tidyverse, um tibble.\n\n\nConvertendo preços diários em retornos mensais com tibbletime.\nFechando esta seção utilizaremos o pacote tibbletime, cujo propósito é trabalhar com tibbles que utilizem tempo.\nNo código a seguir iniciaremos transformando os preços em um tibble com tk_tbl( ). Depois convertermos o objeto num apropriado ao tibbletime com as_tbl_time(index = date) e então converteremos os preços para mensais com as_period(period = “month”, side = “end”). O argumento side ancora o resultado ao fim de cada mês. Se desejásssemos o início faríamos side = “start”*.\n\nasset_returns_tbltime &lt;- \n  prices %&gt;% \n  to.monthly(indexAt = \"lastof\", OHLC = FALSE) %&gt;%\n  tk_tbl(preserve_index = TRUE, rename_index = \"date\") %&gt;%\n  tbl_time(index = \"date\") %&gt;%\n  pivot_longer(cols = -date, names_to = \"asset\", values_to = \"returns\") %&gt;%\n  group_by(date = floor_date(date, 'month')) %&gt;%\n  mutate(returns = log(returns)) %&gt;% \n  na.omit()\n\nEmbora este código, no momento, pareça ineficiente com converções de xts para tibble e depois para tibbletime, nas aulas seguintes veremos que quando precisarmos realizar rolamentos estes serão facilitados pela função rollify( ). Então, absorveremos alguma ineficiência agora para ganhos futuros. Este pacote ainda é muito novo e suas capacidades estão aumentando rapidamente.\n\n\nVisualizando retornos no xts\nUma prática que pode ser útil é visualizar os retornos individuias dos ativos antes de empacotá-los num portifólio. Isto porque dificilmente voltará a analisá-los individualmente depois.\nPara este propósito apresentaremos o pacote highcharter que além de ser capaz de visuais incríveis trabalha com objetos xts.\n\nhighchart(type = \"stock\") %&gt;% \n  hc_title( text = \"Montly Log Returns\") %&gt;% \n  hc_add_series(asset_returns_xts[,symbols[1]],\n                name = symbols[1]) %&gt;% \n  hc_add_series(asset_returns_xts[,symbols[2]],\n                name = symbols[2]) %&gt;% \n  hc_add_series(asset_returns_xts[,symbols[3]],\n                name = symbols[3]) %&gt;% \n  hc_add_series(asset_returns_xts[,symbols[4]],\n                name = symbols[4]) %&gt;% \n  hc_add_series(asset_returns_xts[,symbols[5]],\n                name = symbols[5]) %&gt;% \n  hc_add_theme(hc_theme_flat()) %&gt;% \n  hc_navigator(enabled=FALSE) %&gt;% \n  hc_scrollbar(enabled=FALSE) %&gt;% \n  hc_exporting(enabled=FALSE) %&gt;% \n  hc_legend(enabled=TRUE)\n\n\n\n\n\nNo gráfico temos uma linha para os retornos mensais de cada ativo. Passe o mouse sobre o gráfico e examine como apresenta os dados de cada ativo.\nHicharter também tem a capacidade de fazer histogramas.\n\nhc_hist&lt;-hist(asset_returns_xts[, symbols[1]],\n              breaks= 50,\n              plot = FALSE)\n\nhchart(hc_hist, color=\"cornflowerblue\") %&gt;% \n  hc_title(text= \n             paste(symbols[1],\n                   \"Log Returns Distribution\",\n                   sep= \" \")) %&gt;% \n  hc_add_theme(hc_theme_flat()) %&gt;% \n  hc_exporting(enabled=FALSE) %&gt;% \n  hc_legend(enabled=TRUE) \n\n\n\n\n\nAgora podemos introduzir o conceito de funções para criar os histogramas.\n\nhc_hist_fun&lt;-function( n=1, object, color){\n  hc_hist&lt;-hist(object[,symbols[n]],\n                breaks = 50,\n                plot =FALSE)\nhchart(hc_hist, color = color) %&gt;% \n  hc_title(text = \n             paste(symbols[n],\n                   \"Log Returns Distribution\",\n                   sep= \" \")) %&gt;% \n  hc_add_theme(hc_theme_flat()) %&gt;% \n  hc_exporting(enabled=FALSE) %&gt;% \n  hc_legend(enabled=TRUE) \n}\n\nAgora podemos criar um histograma para cada ativo.\n\nhc_hist_fun(1, asset_returns_xts,\"cornflowerblue\")\n\n\n\n\nhc_hist_fun(2, asset_returns_xts,\"green\")\n\n\n\n\nhc_hist_fun(3, asset_returns_xts,\"pink\")\n\n\n\n\nhc_hist_fun(4, asset_returns_xts,\"purple\")\n\n\n\n\nhc_hist_fun(5, asset_returns_xts,\"yellow\")\n\n\n\n\n\nPoderíamos ter utilizado purrr::map e aplicar a função ao nosso objeto xts, percorrendo cada um dos ativos obtendo um histograma para cada.\n\nmap(1:5, hc_hist_fun, asset_returns_xts, \"blue\")\n\n[[1]]\n\n[[2]]\n\n[[3]]\n\n[[4]]\n\n[[5]]\n\n\n\n\nVisualização com tidyverse\nEste assunto já foi coberto em nossas aulas anteriores. Então seguem os exercícios.\n\n\nExercício 5\nUtilize o ggplot2 e o código abaixo para obter a forma longa do objeto tidyverse desenvolvido no texto. Obtenha um histograma conjunto com uma cor por ativo utilizando os argumentos alpha=0.45 e binwidth = .005. Coloque o título de “Monthly Returns Since 2013”\n\n\nExercício 6 Obtenha o gráfico acima utilizando o conceito de ggplot2:facet_wrap().\n\n\nExercício 7\nRefaça os dois exercícios para a carteira com ativos brasileiros.\n\n\nExercício 8 Obtenha o gráfico das densidades das distribuições dos ativos do objeto tidyverse desenvolvido coloque o título: “Monthly Returns Density Since 2013”e para o eixo x: “monthly returns” e y: “distribution”.\n\n\nExercício 9\nCombine para os ativos do portifólio utilizando o ggplot2::facetwrap os histogramas e densidades. Utilize título: “Monthly Returns Density Since 2013”e para o eixo x: “monthly returns” e y: “distribution”.\nPor hoje é só… obs entregue seus exercícios no schoology.com valem nota."
  }
]